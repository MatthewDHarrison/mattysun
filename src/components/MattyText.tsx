/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { LegacyRef, useMemo, useRef } from 'react'
import {
  useGLTF,
  CurveModifier,
  Text3D,
  Line,
  CurveModifierRef,
} from '@react-three/drei'
import { useFrame, useLoader, useThree } from '@react-three/fiber'
import { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry'
import { FontLoader } from 'three/examples/jsm/loaders/FontLoader'
import * as THREE from 'three'
import helveticaRegular from 'three/examples/fonts/helvetiker_regular.typeface.json'

function CircularText() {
  const textRef = useRef<THREE.Mesh>(null)
  const curvedPoints = []
  const curvedPoints2 = []
  const curvedPoints3 = []
  const radius = 10
  const segments = 50 // Increase this for smoother curves
  const curveRef = useRef<CurveModifierRef>(null)
  const curveRef2 = useRef<CurveModifierRef>(null)
  const curveRef3 = useRef<CurveModifierRef>(null)
  const [textRotation, setTextRotation] = React.useState<THREE.Euler>(
    new THREE.Euler(0, 0, 0),
  )
  // every frame, move the sun around the cloud
  useFrame((state, delta) => {
    const t = state.clock.getElapsedTime()
    const theta = t / 2
    // setTextRotation(prev => new THREE.Euler(0, theta, 0))
    if (curveRef.current) {
      curveRef.current.moveAlongCurve(0.001)
    }
    if (curveRef2.current) {
      curveRef2.current.moveAlongCurve(0.001)
    }
    if (curveRef3.current) {
      curveRef3.current.moveAlongCurve(0.001)
    }
  })
  for (let i = 0; i < segments; i++) {
    const angle = (i / segments) * 2 * Math.PI
    curvedPoints.push(
      new THREE.Vector3(Math.sin(angle) * radius, 0, -Math.cos(angle) * radius),
    )
    curvedPoints2.push(
      new THREE.Vector3(
        Math.sin(angle + (2 * Math.PI) / 3) * radius,
        0,
        -Math.cos(angle + (2 * Math.PI) / 3) * radius,
      ),
    )
    curvedPoints3.push(
      new THREE.Vector3(
        Math.sin(angle + (4 * Math.PI) / 3) * radius,
        0,
        -Math.cos(angle + (4 * Math.PI) / 3) * radius,
      ),
    )
  }
  const curve = new THREE.CatmullRomCurve3(curvedPoints, true)
  const curve2 = new THREE.CatmullRomCurve3(curvedPoints2, true)
  const curve3 = new THREE.CatmullRomCurve3(curvedPoints3, true)

  return (
    <group>
      <CurveModifier curve={curve} ref={curveRef}>
        <Text3D
          ref={textRef}
          font="/fonts/helvetiker_regular.typeface.json" // Make sure to use a valid font path
          size={-1.5}
          bevelEnabled
          bevelThickness={0.05}
          bevelSize={0.01}
          bevelOffset={0}
          bevelSegments={64}
          rotation={[0, 0, Math.PI]} // Rotate the text to correct orientation
        >
          Matty Sun
          <meshPhysicalMaterial color="white" reflectivity={10} />
        </Text3D>
      </CurveModifier>
      <CurveModifier curve={curve2} ref={curveRef2}>
        <Text3D
          ref={textRef}
          font="/fonts/helvetiker_regular.typeface.json" // Make sure to use a valid font path
          size={-1.5}
          bevelEnabled
          bevelThickness={0.05}
          bevelSize={0.01}
          bevelOffset={0}
          bevelSegments={64}
          rotation={[0, 0, Math.PI]} // Rotate the text to correct orientation
        >
          Matty Sun
          <meshPhysicalMaterial color="white" />
        </Text3D>
      </CurveModifier>
      <CurveModifier curve={curve3} ref={curveRef3}>
        <Text3D
          ref={textRef}
          font="/fonts/helvetiker_regular.typeface.json" // Make sure to use a valid font path
          size={-1.5}
          bevelEnabled
          bevelThickness={0.05}
          bevelSize={0.01}
          bevelOffset={0}
          bevelSegments={64}
          rotation={[0, 0, Math.PI]} // Rotate the text to correct orientation
        >
          Matty Sun
          <meshPhysicalMaterial color="white" />
        </Text3D>
      </CurveModifier>
    </group>
  )
}

export const MattyText = (props: any) => {
  let fontLoader = new FontLoader()
  const font = fontLoader.parse(helveticaRegular as any)
  const [textRotation, setTextRotation] = React.useState<THREE.Euler>(
    new THREE.Euler(0, 0, 0),
  )
  const curveRef = useRef<CurveModifierRef>(null)

  // every frame, move the sun around the cloud
  useFrame((state, delta) => {
    const t = state.clock.getElapsedTime()
    const theta = t / 2
    // setTextRotation(prev => new THREE.Euler(0, theta, 0))
    // if (curveRef.current) {
    //   curveRef.current.moveAlongCurve(0.001);
    // }
  })
  const textGeometry = new TextGeometry('Matty Sun', {
    font: font,
    size: 0.25,
    depth: 0.05,
    curveSegments: 12,
    bevelEnabled: true,
    bevelThickness: 0,
    bevelSize: 0,
    bevelOffset: 0,
    bevelSegments: 0,
  })

  const curvedPoints = []
  const radius = 10
  const segments = 50 // Increase this for smoother curves

  for (let i = 0; i < segments; i++) {
    const angle = (i / segments) * 2 * Math.PI
    curvedPoints.push(
      new THREE.Vector3(Math.sin(angle) * radius, 0, -Math.cos(angle) * radius),
    )
  }

  const curve = new THREE.CatmullRomCurve3(curvedPoints.reverse(), true)
  const points = curve.getPoints(50)
  // flow.updateCurve(0, curve)

  return (
    <group {...props} dispose={textRotation}>
      <directionalLight color="white" position={[0, 0, 15]} layers={1} />

      <group>
        {/* <CurveModifier curve={curve} ref={curveRef}>
          <Text3D
            font={'fonts/helvetiker_regular.typeface.json'}
            scale={-1}
            bevelEnabled={true}
            rotation={new THREE.Euler(Math.PI, 0, 0)}
            
          >
            Matty Sun
            <meshBasicMaterial color="white"/>
          </Text3D>
        </CurveModifier> */}
        <CircularText />
        {/* <Text3D
          font={'fonts/helvetiker_regular.typeface.json'}
          scale={0.25}
          bevelEnabled={false}
          // rotation={new THREE.Euler(0, Math.PI, 0)}
        >
          Matty Sun
          <meshBasicMaterial color="white" />
        </Text3D> */}
      </group>
    </group>
  )
}

useGLTF.preload('/models/scene-v1.glb')
