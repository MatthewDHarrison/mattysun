/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useRef } from "react";
import { CameraControls, useGLTF } from "@react-three/drei";
import { useFrame, useLoader, useThree } from "@react-three/fiber";
import * as THREE from "three";
import { Mesh } from "three";
import { TextGroup } from "./Text";

const deg2Rad = (deg: number) => {
  return deg * (Math.PI / 180);
};

interface ISunCloudsProps {
  isPooing: boolean;
}

export const Model = ({ isPooing }: ISunCloudsProps) => {
  const { camera } = useThree();

  camera.position.set(0, 0, 300); // Set position like this
  camera.rotateX(deg2Rad(180)); // Rotate like this
  camera.lookAt(new THREE.Vector3(0, 0, 0)); // Set look at coordinate like this
  camera.layers.enable(1);

  const image = useLoader(THREE.TextureLoader, "assets/josh.jpg");
  const { nodes: crownNodes } = useGLTF("/models/crown.glb");
  const { nodes: pooNodes, materials: pooMaterials } =
    useGLTF("/models/poo.glb");
  const cubeRef = useRef<THREE.Group<THREE.Object3DEventMap>>(null!);
  const crownRef = useRef<THREE.Group<THREE.Object3DEventMap>>(null!);
  const pooRef = useRef<THREE.Group<THREE.Object3DEventMap>>(null!);

  const cubeMaterials = [
    new THREE.MeshBasicMaterial({ map: image }),
    new THREE.MeshBasicMaterial({ map: image }),
    new THREE.MeshBasicMaterial({ map: image }),
    new THREE.MeshBasicMaterial({ map: image }),
    new THREE.MeshBasicMaterial({ map: image }),
    new THREE.MeshBasicMaterial({ map: image }),
  ];
  var cubeGeometry = new THREE.BoxGeometry(100, 100, 100);
  const crownMaterial = new THREE.MeshStandardMaterial({
    color: "#FDD022",
    metalness: 0.75,
    roughness: 0.5,
    lightMapIntensity: 1.5,
  });

  var cube = new THREE.Mesh(cubeGeometry, cubeMaterials);

  useEffect(() => {
    camera.layers.enable(0);
    if (cubeRef.current) {
      cubeRef.current.position.set(0, -100, 0);
    }
    if (crownRef.current) {
      crownRef.current.position.set(0, 200, 0);
      crownRef.current.rotation.set(deg2Rad(20), 0, 0);
    }
    if (pooRef.current) {
      pooRef.current.position.set(0, 100, 0);
      pooRef.current.rotation.set(deg2Rad(-70), deg2Rad(-10), deg2Rad(40));
    }
  }, []);

  // every frame, rotate the cubeRef a bit
  useFrame((state, delta) => {
    if (cubeRef.current) {
      cubeRef.current.rotation.y += 0.01;
    }
    if (crownRef.current) {
      crownRef.current.rotation.y -= 0.01;
    }
    if (isPooing) {
      if (pooRef.current) {
        pooRef.current.position.y -= 2;
      }
    }
  });

  useEffect(() => {
    if (isPooing) {
      if (pooRef.current) {
        pooRef.current.position.set(0, 50, 0);
        pooRef.current.rotation.set(deg2Rad(-70), deg2Rad(-10), deg2Rad(40));
      }
    }
  }, [isPooing]);

  return (
    <group dispose={null}>
      <CameraControls minPolarAngle={0} maxPolarAngle={Math.PI / 1.6} />
      <group
        ref={cubeRef}
        rotation={[0, deg2Rad(-20), deg2Rad(10)]}
        scale={0.8}
      >
        <mesh geometry={cube.geometry} material={cube.material} />
      </group>
      <directionalLight position={[0, 0, 300]} intensity={5} />
      <group ref={crownRef}>
        <mesh
          position={[0, 0, 0]}
          scale={750}
          geometry={(crownNodes.Node1 as THREE.Mesh).geometry}
          material={crownMaterial}
        />
      </group>
      {isPooing && (
        <group ref={pooRef} scale={30}>
          <mesh
            position={[0, 0, 0]}
            geometry={(pooNodes.Object_3 as THREE.Mesh).geometry}
            material={(pooNodes.Object_3 as THREE.Mesh).material}
          />

          <mesh
            position={[0, 0, 0]}
            geometry={(pooNodes.Object_2 as THREE.Mesh).geometry}
            material={(pooNodes.Object_2 as THREE.Mesh).material}
          />
        </group>
      )}
      <TextGroup />
    </group>
  );
};

useGLTF.preload("/models/scene-v1.glb");
